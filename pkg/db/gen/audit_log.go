// Code generated by 'gorm.io/cli/gorm'. DO NOT EDIT.

package gen

import (
	"context"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/pixlcrashr/roomy/pkg/db/model"
	"gorm.io/cli/gorm/typed"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

func AuditLogQuery[T any](db *gorm.DB, opts ...clause.Expression) _AuditLogQueryInterface[T] {
	return _AuditLogQueryImpl[T]{
		Interface: typed.G[T](db, opts...),
	}
}

type _AuditLogQueryInterface[T any] interface {
	typed.Interface[T]
	List(ctx context.Context, limit int, offset int, userID *uuid.UUID, action *string, entityType *string, entityID *uuid.UUID, startDate *time.Time, endDate *time.Time) ([]*model.AuditLogEntry, error)
	CountAll(ctx context.Context, userID *uuid.UUID, action *string, entityType *string, entityID *uuid.UUID, startDate *time.Time, endDate *time.Time) (int64, error)
	Insert(ctx context.Context, id uuid.UUID, userID *uuid.UUID, action string, entityType string, entityID uuid.UUID, oldValue *string, newValue *string, ipAddress *string, userAgent *string) error
}

type _AuditLogQueryImpl[T any] struct {
	typed.Interface[T]
}

func (e _AuditLogQueryImpl[T]) List(ctx context.Context, limit int, offset int, userID *uuid.UUID, action *string, entityType *string, entityID *uuid.UUID, startDate *time.Time, endDate *time.Time) ([]*model.AuditLogEntry, error) {
	var sb strings.Builder
	_params := make([]any, 0, 9)

	sb.WriteString("SELECT * FROM ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		if userID != nil {
			tmp.WriteString(" user_id = ?")
			_params = append(_params, userID)
		}
		if action != nil {
			tmp.WriteString(" AND action = ?")
			_params = append(_params, action)
		}
		if entityType != nil {
			tmp.WriteString(" AND entity_type = ?")
			_params = append(_params, entityType)
		}
		if entityID != nil {
			tmp.WriteString(" AND entity_id = ?")
			_params = append(_params, entityID)
		}
		if startDate != nil {
			tmp.WriteString(" AND created_at >= ?")
			_params = append(_params, startDate)
		}
		if endDate != nil {
			tmp.WriteString(" AND created_at <= ?")
			_params = append(_params, endDate)
		}
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			reTrim := regexp.MustCompile(`(?i)^\s*(?:and|or)\s+|\s+(?:and|or)\s*$`)
			c = reTrim.ReplaceAllString(c, "")
			sb.WriteString(" WHERE ")
			sb.WriteString(c)
		}
	}
	sb.WriteString(" ORDER BY created_at DESC")
	sb.WriteString(" LIMIT ? OFFSET ?")
	_params = append(_params, limit, offset)

	var result []*model.AuditLogEntry
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _AuditLogQueryImpl[T]) CountAll(ctx context.Context, userID *uuid.UUID, action *string, entityType *string, entityID *uuid.UUID, startDate *time.Time, endDate *time.Time) (int64, error) {
	var sb strings.Builder
	_params := make([]any, 0, 7)

	sb.WriteString("SELECT COUNT(*) FROM ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		if userID != nil {
			tmp.WriteString(" user_id = ?")
			_params = append(_params, userID)
		}
		if action != nil {
			tmp.WriteString(" AND action = ?")
			_params = append(_params, action)
		}
		if entityType != nil {
			tmp.WriteString(" AND entity_type = ?")
			_params = append(_params, entityType)
		}
		if entityID != nil {
			tmp.WriteString(" AND entity_id = ?")
			_params = append(_params, entityID)
		}
		if startDate != nil {
			tmp.WriteString(" AND created_at >= ?")
			_params = append(_params, startDate)
		}
		if endDate != nil {
			tmp.WriteString(" AND created_at <= ?")
			_params = append(_params, endDate)
		}
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			reTrim := regexp.MustCompile(`(?i)^\s*(?:and|or)\s+|\s+(?:and|or)\s*$`)
			c = reTrim.ReplaceAllString(c, "")
			sb.WriteString(" WHERE ")
			sb.WriteString(c)
		}
	}

	var result int64
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _AuditLogQueryImpl[T]) Insert(ctx context.Context, id uuid.UUID, userID *uuid.UUID, action string, entityType string, entityID uuid.UUID, oldValue *string, newValue *string, ipAddress *string, userAgent *string) error {
	var sb strings.Builder
	_params := make([]any, 0, 10)

	sb.WriteString("INSERT INTO ? (id, user_id, action, entity_type, entity_id, old_value, new_value, ip_address, user_agent, created_at)")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	sb.WriteString(" VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())")
	_params = append(_params, id, userID, action, entityType, entityID, oldValue, newValue, ipAddress, userAgent)

	return e.Exec(ctx, sb.String(), _params...)
}

// Code generated by 'gorm.io/cli/gorm'. DO NOT EDIT.

package gen

import (
	"context"
	"regexp"
	"strings"

	"github.com/google/uuid"
	"github.com/pixlcrashr/roomy/pkg/db/model"
	"gorm.io/cli/gorm/typed"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

func PlaceQuery[T any](db *gorm.DB, opts ...clause.Expression) _PlaceQueryInterface[T] {
	return _PlaceQueryImpl[T]{
		Interface: typed.G[T](db, opts...),
	}
}

type _PlaceQueryInterface[T any] interface {
	typed.Interface[T]
	GetByID(ctx context.Context, id uuid.UUID) (*model.Place, error)
	List(ctx context.Context, limit int, offset int, areaID *uuid.UUID, buildingID *uuid.UUID, search *string, minCapacity *int, isBookable *bool) ([]*model.Place, error)
	CountAll(ctx context.Context, areaID *uuid.UUID, buildingID *uuid.UUID, search *string, minCapacity *int, isBookable *bool) (int64, error)
	ListByArea(ctx context.Context, areaID uuid.UUID) ([]*model.Place, error)
	Insert(ctx context.Context, id uuid.UUID, areaID uuid.UUID, name string, description *string, seatCapacity int, isBookable bool, isDisabled bool, maxReservationDuration *int, maxReservationsPerDay *int, maxReservationsPerWeek *int, maxReservationsPerMonth *int, maxReservationsPerYear *int, requiresCheckIn bool, checkInTimeoutMinutes *int, hasWhitelist bool, bookingWindowDays *int, minBookingDuration *int, timeSlotIntervalMinutes int, dayStartHour int, dayEndHour int) error
	Save(ctx context.Context, id uuid.UUID, name *string, description *string, seatCapacity *int, isBookable *bool, isDisabled *bool) error
	UpdateConstraints(ctx context.Context, id uuid.UUID, maxReservationDuration *int, maxReservationsPerDay *int, maxReservationsPerWeek *int, maxReservationsPerMonth *int, maxReservationsPerYear *int, requiresCheckIn *bool, checkInTimeoutMinutes *int, hasWhitelist *bool, bookingWindowDays *int, minBookingDuration *int) error
	UpdateTimeSlots(ctx context.Context, id uuid.UUID, timeSlotIntervalMinutes *int, dayStartHour *int, dayEndHour *int) error
	Remove(ctx context.Context, id uuid.UUID) error
}

type _PlaceQueryImpl[T any] struct {
	typed.Interface[T]
}

func (e _PlaceQueryImpl[T]) GetByID(ctx context.Context, id uuid.UUID) (*model.Place, error) {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("SELECT * FROM ? WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, id)

	var result *model.Place
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _PlaceQueryImpl[T]) List(ctx context.Context, limit int, offset int, areaID *uuid.UUID, buildingID *uuid.UUID, search *string, minCapacity *int, isBookable *bool) ([]*model.Place, error) {
	var sb strings.Builder
	_params := make([]any, 0, 9)

	sb.WriteString("SELECT p.* FROM ? p")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	sb.WriteString(" LEFT JOIN areas a ON a.id = p.area_id")
	{
		var tmp strings.Builder
		if areaID != nil {
			tmp.WriteString(" p.area_id = ?")
			_params = append(_params, areaID)
		}
		if buildingID != nil {
			tmp.WriteString(" AND a.building_id = ?")
			_params = append(_params, buildingID)
		}
		if search != nil {
			tmp.WriteString(" AND (p.name ILIKE ? OR p.description ILIKE ?)")
			_params = append(_params, search, search)
		}
		if minCapacity != nil {
			tmp.WriteString(" AND p.seat_capacity >= ?")
			_params = append(_params, minCapacity)
		}
		if isBookable != nil {
			tmp.WriteString(" AND p.is_bookable = ?")
			_params = append(_params, isBookable)
		}
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			reTrim := regexp.MustCompile(`(?i)^\s*(?:and|or)\s+|\s+(?:and|or)\s*$`)
			c = reTrim.ReplaceAllString(c, "")
			sb.WriteString(" WHERE ")
			sb.WriteString(c)
		}
	}
	sb.WriteString(" ORDER BY p.created_at DESC")
	sb.WriteString(" LIMIT ? OFFSET ?")
	_params = append(_params, limit, offset)

	var result []*model.Place
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _PlaceQueryImpl[T]) CountAll(ctx context.Context, areaID *uuid.UUID, buildingID *uuid.UUID, search *string, minCapacity *int, isBookable *bool) (int64, error) {
	var sb strings.Builder
	_params := make([]any, 0, 7)

	sb.WriteString("SELECT COUNT(p.id) FROM ? p")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	sb.WriteString(" LEFT JOIN areas a ON a.id = p.area_id")
	{
		var tmp strings.Builder
		if areaID != nil {
			tmp.WriteString(" p.area_id = ?")
			_params = append(_params, areaID)
		}
		if buildingID != nil {
			tmp.WriteString(" AND a.building_id = ?")
			_params = append(_params, buildingID)
		}
		if search != nil {
			tmp.WriteString(" AND (p.name ILIKE ? OR p.description ILIKE ?)")
			_params = append(_params, search, search)
		}
		if minCapacity != nil {
			tmp.WriteString(" AND p.seat_capacity >= ?")
			_params = append(_params, minCapacity)
		}
		if isBookable != nil {
			tmp.WriteString(" AND p.is_bookable = ?")
			_params = append(_params, isBookable)
		}
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			reTrim := regexp.MustCompile(`(?i)^\s*(?:and|or)\s+|\s+(?:and|or)\s*$`)
			c = reTrim.ReplaceAllString(c, "")
			sb.WriteString(" WHERE ")
			sb.WriteString(c)
		}
	}

	var result int64
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _PlaceQueryImpl[T]) ListByArea(ctx context.Context, areaID uuid.UUID) ([]*model.Place, error) {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("SELECT * FROM ? WHERE area_id = ? ORDER BY created_at DESC")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, areaID)

	var result []*model.Place
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _PlaceQueryImpl[T]) Insert(ctx context.Context, id uuid.UUID, areaID uuid.UUID, name string, description *string, seatCapacity int, isBookable bool, isDisabled bool, maxReservationDuration *int, maxReservationsPerDay *int, maxReservationsPerWeek *int, maxReservationsPerMonth *int, maxReservationsPerYear *int, requiresCheckIn bool, checkInTimeoutMinutes *int, hasWhitelist bool, bookingWindowDays *int, minBookingDuration *int, timeSlotIntervalMinutes int, dayStartHour int, dayEndHour int) error {
	var sb strings.Builder
	_params := make([]any, 0, 21)

	sb.WriteString("INSERT INTO ? (")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	sb.WriteString(" id, area_id, name, description, seat_capacity, is_bookable, is_disabled,")
	sb.WriteString(" max_reservation_duration, max_reservations_per_day, max_reservations_per_week,")
	sb.WriteString(" max_reservations_per_month, max_reservations_per_year, requires_check_in,")
	sb.WriteString(" check_in_timeout_minutes, has_whitelist, booking_window_days, min_booking_duration,")
	sb.WriteString(" time_slot_interval_minutes, day_start_hour, day_end_hour, created_at, updated_at")
	sb.WriteString(" ) VALUES (")
	sb.WriteString(" ?, ?, ?, ?, ?, ?, ?,")
	_params = append(_params, id, areaID, name, description, seatCapacity, isBookable, isDisabled)
	sb.WriteString(" ?, ?, ?,")
	_params = append(_params, maxReservationDuration, maxReservationsPerDay, maxReservationsPerWeek)
	sb.WriteString(" ?, ?, ?,")
	_params = append(_params, maxReservationsPerMonth, maxReservationsPerYear, requiresCheckIn)
	sb.WriteString(" ?, ?, ?, ?,")
	_params = append(_params, checkInTimeoutMinutes, hasWhitelist, bookingWindowDays, minBookingDuration)
	sb.WriteString(" ?, ?, ?, NOW(), NOW()")
	_params = append(_params, timeSlotIntervalMinutes, dayStartHour, dayEndHour)
	sb.WriteString(" )")

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _PlaceQueryImpl[T]) Save(ctx context.Context, id uuid.UUID, name *string, description *string, seatCapacity *int, isBookable *bool, isDisabled *bool) error {
	var sb strings.Builder
	_params := make([]any, 0, 7)

	sb.WriteString("UPDATE ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		if name != nil {
			tmp.WriteString(" name = ?,")
			_params = append(_params, name)
		}
		if description != nil {
			tmp.WriteString(" description = ?,")
			_params = append(_params, description)
		}
		if seatCapacity != nil {
			tmp.WriteString(" seat_capacity = ?,")
			_params = append(_params, seatCapacity)
		}
		if isBookable != nil {
			tmp.WriteString(" is_bookable = ?,")
			_params = append(_params, isBookable)
		}
		if isDisabled != nil {
			tmp.WriteString(" is_disabled = ?,")
			_params = append(_params, isDisabled)
		}
		tmp.WriteString(" updated_at = NOW()")
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			c = strings.Trim(c, ", ")
			sb.WriteString(" SET ")
			sb.WriteString(c)
		}
	}
	sb.WriteString(" WHERE id = ?")
	_params = append(_params, id)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _PlaceQueryImpl[T]) UpdateConstraints(ctx context.Context, id uuid.UUID, maxReservationDuration *int, maxReservationsPerDay *int, maxReservationsPerWeek *int, maxReservationsPerMonth *int, maxReservationsPerYear *int, requiresCheckIn *bool, checkInTimeoutMinutes *int, hasWhitelist *bool, bookingWindowDays *int, minBookingDuration *int) error {
	var sb strings.Builder
	_params := make([]any, 0, 12)

	sb.WriteString("UPDATE ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		if maxReservationDuration != nil {
			tmp.WriteString(" max_reservation_duration = ?,")
			_params = append(_params, maxReservationDuration)
		}
		if maxReservationsPerDay != nil {
			tmp.WriteString(" max_reservations_per_day = ?,")
			_params = append(_params, maxReservationsPerDay)
		}
		if maxReservationsPerWeek != nil {
			tmp.WriteString(" max_reservations_per_week = ?,")
			_params = append(_params, maxReservationsPerWeek)
		}
		if maxReservationsPerMonth != nil {
			tmp.WriteString(" max_reservations_per_month = ?,")
			_params = append(_params, maxReservationsPerMonth)
		}
		if maxReservationsPerYear != nil {
			tmp.WriteString(" max_reservations_per_year = ?,")
			_params = append(_params, maxReservationsPerYear)
		}
		if requiresCheckIn != nil {
			tmp.WriteString(" requires_check_in = ?,")
			_params = append(_params, requiresCheckIn)
		}
		if checkInTimeoutMinutes != nil {
			tmp.WriteString(" check_in_timeout_minutes = ?,")
			_params = append(_params, checkInTimeoutMinutes)
		}
		if hasWhitelist != nil {
			tmp.WriteString(" has_whitelist = ?,")
			_params = append(_params, hasWhitelist)
		}
		if bookingWindowDays != nil {
			tmp.WriteString(" booking_window_days = ?,")
			_params = append(_params, bookingWindowDays)
		}
		if minBookingDuration != nil {
			tmp.WriteString(" min_booking_duration = ?,")
			_params = append(_params, minBookingDuration)
		}
		tmp.WriteString(" updated_at = NOW()")
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			c = strings.Trim(c, ", ")
			sb.WriteString(" SET ")
			sb.WriteString(c)
		}
	}
	sb.WriteString(" WHERE id = ?")
	_params = append(_params, id)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _PlaceQueryImpl[T]) UpdateTimeSlots(ctx context.Context, id uuid.UUID, timeSlotIntervalMinutes *int, dayStartHour *int, dayEndHour *int) error {
	var sb strings.Builder
	_params := make([]any, 0, 5)

	sb.WriteString("UPDATE ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		if timeSlotIntervalMinutes != nil {
			tmp.WriteString(" time_slot_interval_minutes = ?,")
			_params = append(_params, timeSlotIntervalMinutes)
		}
		if dayStartHour != nil {
			tmp.WriteString(" day_start_hour = ?,")
			_params = append(_params, dayStartHour)
		}
		if dayEndHour != nil {
			tmp.WriteString(" day_end_hour = ?,")
			_params = append(_params, dayEndHour)
		}
		tmp.WriteString(" updated_at = NOW()")
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			c = strings.Trim(c, ", ")
			sb.WriteString(" SET ")
			sb.WriteString(c)
		}
	}
	sb.WriteString(" WHERE id = ?")
	_params = append(_params, id)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _PlaceQueryImpl[T]) Remove(ctx context.Context, id uuid.UUID) error {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("DELETE FROM ? WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, id)

	return e.Exec(ctx, sb.String(), _params...)
}

// Code generated by 'gorm.io/cli/gorm'. DO NOT EDIT.

package gen

import (
	"context"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/pixlcrashr/roomy/pkg/db/model"
	"gorm.io/cli/gorm/typed"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

func BlockingQuery[T any](db *gorm.DB, opts ...clause.Expression) _BlockingQueryInterface[T] {
	return _BlockingQueryImpl[T]{
		Interface: typed.G[T](db, opts...),
	}
}

type _BlockingQueryInterface[T any] interface {
	typed.Interface[T]
	GetByID(ctx context.Context, id uuid.UUID) (*model.Blocking, error)
	ListByEntity(ctx context.Context, entityType string, entityID uuid.UUID) ([]*model.Blocking, error)
	ListByEntityAndTimeRange(ctx context.Context, entityType string, entityID uuid.UUID, startAfter *time.Time, endBefore *time.Time) ([]*model.Blocking, error)
	ListInheritedForPlace(ctx context.Context, placeID uuid.UUID, areaID uuid.UUID, buildingID uuid.UUID) ([]*model.Blocking, error)
	Insert(ctx context.Context, id uuid.UUID, entityType string, entityID uuid.UUID, blockingType string, startTime time.Time, endTime time.Time, isRecurring bool, recurrencePattern *string, recurrenceEnd *time.Time, reason *string, createdBy *uuid.UUID) error
	Remove(ctx context.Context, id uuid.UUID) error
	DeleteByIDs(ctx context.Context, entityType string, entityID uuid.UUID, ids []uuid.UUID) error
	DeleteByEntity(ctx context.Context, entityType string, entityID uuid.UUID) error
}

type _BlockingQueryImpl[T any] struct {
	typed.Interface[T]
}

func (e _BlockingQueryImpl[T]) GetByID(ctx context.Context, id uuid.UUID) (*model.Blocking, error) {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("SELECT * FROM ? WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, id)

	var result *model.Blocking
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _BlockingQueryImpl[T]) ListByEntity(ctx context.Context, entityType string, entityID uuid.UUID) ([]*model.Blocking, error) {
	var sb strings.Builder
	_params := make([]any, 0, 3)

	sb.WriteString("SELECT * FROM ? WHERE entity_type = ? AND entity_id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, entityType, entityID)
	sb.WriteString(" ORDER BY start_time")

	var result []*model.Blocking
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _BlockingQueryImpl[T]) ListByEntityAndTimeRange(ctx context.Context, entityType string, entityID uuid.UUID, startAfter *time.Time, endBefore *time.Time) ([]*model.Blocking, error) {
	var sb strings.Builder
	_params := make([]any, 0, 5)

	sb.WriteString("SELECT * FROM ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		tmp.WriteString(" entity_type = ? AND entity_id = ?")
		_params = append(_params, entityType, entityID)
		if startAfter != nil {
			tmp.WriteString(" AND start_time >= ?")
			_params = append(_params, startAfter)
		}
		if endBefore != nil {
			tmp.WriteString(" AND end_time <= ?")
			_params = append(_params, endBefore)
		}
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			reTrim := regexp.MustCompile(`(?i)^\s*(?:and|or)\s+|\s+(?:and|or)\s*$`)
			c = reTrim.ReplaceAllString(c, "")
			sb.WriteString(" WHERE ")
			sb.WriteString(c)
		}
	}
	sb.WriteString(" ORDER BY start_time")

	var result []*model.Blocking
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _BlockingQueryImpl[T]) ListInheritedForPlace(ctx context.Context, placeID uuid.UUID, areaID uuid.UUID, buildingID uuid.UUID) ([]*model.Blocking, error) {
	var sb strings.Builder
	_params := make([]any, 0, 4)

	sb.WriteString("SELECT * FROM ? WHERE")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	sb.WriteString(" (entity_type = 'place' AND entity_id = ?)")
	_params = append(_params, placeID)
	sb.WriteString(" OR (entity_type = 'area' AND entity_id = ?)")
	_params = append(_params, areaID)
	sb.WriteString(" OR (entity_type = 'building' AND entity_id = ?)")
	_params = append(_params, buildingID)
	sb.WriteString(" ORDER BY start_time")

	var result []*model.Blocking
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _BlockingQueryImpl[T]) Insert(ctx context.Context, id uuid.UUID, entityType string, entityID uuid.UUID, blockingType string, startTime time.Time, endTime time.Time, isRecurring bool, recurrencePattern *string, recurrenceEnd *time.Time, reason *string, createdBy *uuid.UUID) error {
	var sb strings.Builder
	_params := make([]any, 0, 12)

	sb.WriteString("INSERT INTO ? (")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	sb.WriteString(" id, entity_type, entity_id, blocking_type, start_time, end_time,")
	sb.WriteString(" is_recurring, recurrence_pattern, recurrence_end, reason, created_by, created_at")
	sb.WriteString(" ) VALUES (")
	sb.WriteString(" ?, ?, ?, ?, ?, ?,")
	_params = append(_params, id, entityType, entityID, blockingType, startTime, endTime)
	sb.WriteString(" ?, ?, ?, ?, ?, NOW()")
	_params = append(_params, isRecurring, recurrencePattern, recurrenceEnd, reason, createdBy)
	sb.WriteString(" )")

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _BlockingQueryImpl[T]) Remove(ctx context.Context, id uuid.UUID) error {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("DELETE FROM ? WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, id)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _BlockingQueryImpl[T]) DeleteByIDs(ctx context.Context, entityType string, entityID uuid.UUID, ids []uuid.UUID) error {
	var sb strings.Builder
	_params := make([]any, 0, 4)

	sb.WriteString("DELETE FROM ? WHERE entity_type = ? AND entity_id = ? AND id IN (?)")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, entityType, entityID, ids)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _BlockingQueryImpl[T]) DeleteByEntity(ctx context.Context, entityType string, entityID uuid.UUID) error {
	var sb strings.Builder
	_params := make([]any, 0, 3)

	sb.WriteString("DELETE FROM ? WHERE entity_type = ? AND entity_id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, entityType, entityID)

	return e.Exec(ctx, sb.String(), _params...)
}

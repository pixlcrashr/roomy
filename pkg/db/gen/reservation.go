// Code generated by 'gorm.io/cli/gorm'. DO NOT EDIT.

package gen

import (
	"context"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/pixlcrashr/roomy/pkg/db/model"
	"gorm.io/cli/gorm/typed"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

func ReservationQuery[T any](db *gorm.DB, opts ...clause.Expression) _ReservationQueryInterface[T] {
	return _ReservationQueryImpl[T]{
		Interface: typed.G[T](db, opts...),
	}
}

type _ReservationQueryInterface[T any] interface {
	typed.Interface[T]
	GetByID(ctx context.Context, id uuid.UUID) (*model.Reservation, error)
	List(ctx context.Context, limit int, offset int, placeID *uuid.UUID, userID *uuid.UUID, status *string, startAfter *time.Time, endBefore *time.Time) ([]*model.Reservation, error)
	CountAll(ctx context.Context, placeID *uuid.UUID, userID *uuid.UUID, status *string, startAfter *time.Time, endBefore *time.Time) (int64, error)
	ListByUser(ctx context.Context, userID uuid.UUID) ([]*model.Reservation, error)
	ListByPlaceAndTimeRange(ctx context.Context, placeID uuid.UUID, startTime time.Time, endTime time.Time) ([]*model.Reservation, error)
	Insert(ctx context.Context, id uuid.UUID, placeID uuid.UUID, userID uuid.UUID, startTime time.Time, endTime time.Time, status string, isRecurring bool, recurringGroupID *uuid.UUID) error
	Save(ctx context.Context, id uuid.UUID, startTime *time.Time, endTime *time.Time) error
	UpdateStatus(ctx context.Context, id uuid.UUID, status string) error
	Cancel(ctx context.Context, id uuid.UUID, reason *string) error
	CheckIn(ctx context.Context, id uuid.UUID) error
	Remove(ctx context.Context, id uuid.UUID) error
}

type _ReservationQueryImpl[T any] struct {
	typed.Interface[T]
}

func (e _ReservationQueryImpl[T]) GetByID(ctx context.Context, id uuid.UUID) (*model.Reservation, error) {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("SELECT * FROM ? WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, id)

	var result *model.Reservation
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _ReservationQueryImpl[T]) List(ctx context.Context, limit int, offset int, placeID *uuid.UUID, userID *uuid.UUID, status *string, startAfter *time.Time, endBefore *time.Time) ([]*model.Reservation, error) {
	var sb strings.Builder
	_params := make([]any, 0, 8)

	sb.WriteString("SELECT * FROM ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		if placeID != nil {
			tmp.WriteString(" place_id = ?")
			_params = append(_params, placeID)
		}
		if userID != nil {
			tmp.WriteString(" AND user_id = ?")
			_params = append(_params, userID)
		}
		if status != nil {
			tmp.WriteString(" AND status = ?")
			_params = append(_params, status)
		}
		if startAfter != nil {
			tmp.WriteString(" AND start_time >= ?")
			_params = append(_params, startAfter)
		}
		if endBefore != nil {
			tmp.WriteString(" AND end_time <= ?")
			_params = append(_params, endBefore)
		}
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			reTrim := regexp.MustCompile(`(?i)^\s*(?:and|or)\s+|\s+(?:and|or)\s*$`)
			c = reTrim.ReplaceAllString(c, "")
			sb.WriteString(" WHERE ")
			sb.WriteString(c)
		}
	}
	sb.WriteString(" ORDER BY start_time DESC")
	sb.WriteString(" LIMIT ? OFFSET ?")
	_params = append(_params, limit, offset)

	var result []*model.Reservation
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _ReservationQueryImpl[T]) CountAll(ctx context.Context, placeID *uuid.UUID, userID *uuid.UUID, status *string, startAfter *time.Time, endBefore *time.Time) (int64, error) {
	var sb strings.Builder
	_params := make([]any, 0, 6)

	sb.WriteString("SELECT COUNT(*) FROM ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		if placeID != nil {
			tmp.WriteString(" place_id = ?")
			_params = append(_params, placeID)
		}
		if userID != nil {
			tmp.WriteString(" AND user_id = ?")
			_params = append(_params, userID)
		}
		if status != nil {
			tmp.WriteString(" AND status = ?")
			_params = append(_params, status)
		}
		if startAfter != nil {
			tmp.WriteString(" AND start_time >= ?")
			_params = append(_params, startAfter)
		}
		if endBefore != nil {
			tmp.WriteString(" AND end_time <= ?")
			_params = append(_params, endBefore)
		}
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			reTrim := regexp.MustCompile(`(?i)^\s*(?:and|or)\s+|\s+(?:and|or)\s*$`)
			c = reTrim.ReplaceAllString(c, "")
			sb.WriteString(" WHERE ")
			sb.WriteString(c)
		}
	}

	var result int64
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _ReservationQueryImpl[T]) ListByUser(ctx context.Context, userID uuid.UUID) ([]*model.Reservation, error) {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("SELECT * FROM ? WHERE user_id = ? ORDER BY start_time DESC")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, userID)

	var result []*model.Reservation
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _ReservationQueryImpl[T]) ListByPlaceAndTimeRange(ctx context.Context, placeID uuid.UUID, startTime time.Time, endTime time.Time) ([]*model.Reservation, error) {
	var sb strings.Builder
	_params := make([]any, 0, 4)

	sb.WriteString("SELECT * FROM ? WHERE place_id = ? AND start_time >= ? AND end_time <= ? ORDER BY start_time")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, placeID, startTime, endTime)

	var result []*model.Reservation
	err := e.Raw(sb.String(), _params...).Scan(ctx, &result)
	return result, err
}

func (e _ReservationQueryImpl[T]) Insert(ctx context.Context, id uuid.UUID, placeID uuid.UUID, userID uuid.UUID, startTime time.Time, endTime time.Time, status string, isRecurring bool, recurringGroupID *uuid.UUID) error {
	var sb strings.Builder
	_params := make([]any, 0, 9)

	sb.WriteString("INSERT INTO ? (")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	sb.WriteString(" id, place_id, user_id, start_time, end_time, status, is_recurring,")
	sb.WriteString(" recurring_group_id, created_at, updated_at")
	sb.WriteString(" ) VALUES (")
	sb.WriteString(" ?, ?, ?, ?, ?, ?, ?,")
	_params = append(_params, id, placeID, userID, startTime, endTime, status, isRecurring)
	sb.WriteString(" ?, NOW(), NOW()")
	_params = append(_params, recurringGroupID)
	sb.WriteString(" )")

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _ReservationQueryImpl[T]) Save(ctx context.Context, id uuid.UUID, startTime *time.Time, endTime *time.Time) error {
	var sb strings.Builder
	_params := make([]any, 0, 4)

	sb.WriteString("UPDATE ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable})
	{
		var tmp strings.Builder
		if startTime != nil {
			tmp.WriteString(" start_time = ?,")
			_params = append(_params, startTime)
		}
		if endTime != nil {
			tmp.WriteString(" end_time = ?,")
			_params = append(_params, endTime)
		}
		tmp.WriteString(" updated_at = NOW()")
		c := strings.TrimSpace(tmp.String())
		if c != "" {
			c = strings.Trim(c, ", ")
			sb.WriteString(" SET ")
			sb.WriteString(c)
		}
	}
	sb.WriteString(" WHERE id = ?")
	_params = append(_params, id)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _ReservationQueryImpl[T]) UpdateStatus(ctx context.Context, id uuid.UUID, status string) error {
	var sb strings.Builder
	_params := make([]any, 0, 3)

	sb.WriteString("UPDATE ? SET status = ?, updated_at = NOW() WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, status, id)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _ReservationQueryImpl[T]) Cancel(ctx context.Context, id uuid.UUID, reason *string) error {
	var sb strings.Builder
	_params := make([]any, 0, 3)

	sb.WriteString("UPDATE ? SET status = 'cancelled', cancel_reason = ?, updated_at = NOW() WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, reason, id)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _ReservationQueryImpl[T]) CheckIn(ctx context.Context, id uuid.UUID) error {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("UPDATE ? SET status = 'checkedIn', check_in_time = NOW(), updated_at = NOW() WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, id)

	return e.Exec(ctx, sb.String(), _params...)
}

func (e _ReservationQueryImpl[T]) Remove(ctx context.Context, id uuid.UUID) error {
	var sb strings.Builder
	_params := make([]any, 0, 2)

	sb.WriteString("DELETE FROM ? WHERE id = ?")
	_params = append(_params, clause.Table{Name: clause.CurrentTable}, id)

	return e.Exec(ctx, sb.String(), _params...)
}
